<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/spec/models/invoice_spec.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/spec/models/invoice_spec.rb" />
              <option name="originalContent" value="require 'rails_helper'&#10;&#10;RSpec.describe Invoice do&#10;  include ActiveSupport::Testing::TimeHelpers&#10;&#10;  describe 'FactoryBot' do&#10;    subject(:invoice) { create(:invoice) }&#10;&#10;    specify { expect(invoice.date).to eq Date.new(2025, 2, 1) }&#10;    specify { expect(invoice.client_sessions.length).to eq 3 }&#10;  end&#10;&#10;  describe '::create' do&#10;    context 'when it is a new invoice' do&#10;      let(:invoice_params) { attributes_for(:invoice, client_id: client.id) }&#10;      let(:client) { create(:client, :with_client_sessions) }&#10;&#10;      it 'creates the invoice and associates all the client sessions' do&#10;        client_session_ids = client.client_session_ids&#10;        amount = Money.new(ClientSession.where(id: client_session_ids).sum(&amp;:fee), 'GBP')&#10;&#10;        invoice_params[:client_session_ids] = client_session_ids&#10;&#10;        invoice = Invoice.create(invoice_params)&#10;&#10;        expect(invoice.client_sessions.pluck(:id)).to match client_session_ids&#10;        expect(invoice.amount).to eq(amount)&#10;      end&#10;&#10;      it 'creates the invoice and associates some of the client sessions' do&#10;        client_session_ids = client.client_session_ids&#10;        first_client_session_id = client_session_ids.pop&#10;&#10;        invoice_params[:client_session_ids] = client_session_ids&#10;        invoice = Invoice.create(invoice_params)&#10;&#10;        expect(invoice.client_sessions.pluck(:id)).to match client_session_ids&#10;        expect(ClientSession.find(first_client_session_id).invoice_id).to be_nil&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'destruction' do&#10;    context 'when invoice status is created' do&#10;      it 'allows destruction' do&#10;        invoice = create(:invoice, status: :created)&#10;        expect(invoice.destroy).not_to be_falsey&#10;        expect(invoice.persisted?).to be_falsey&#10;      end&#10;    end&#10;&#10;    context 'when invoice status is sent' do&#10;      it 'prevents destruction' do&#10;        invoice = create(:invoice, status: :sent)&#10;        expect(invoice.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        invoice = create(:invoice, status: :sent)&#10;        invoice.destroy&#10;        expect(invoice.persisted?).to be true&#10;      end&#10;    end&#10;&#10;    context 'when invoice status is paid' do&#10;      it 'prevents destruction' do&#10;        invoice = create(:invoice, status: :paid)&#10;        expect(invoice.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        invoice = create(:invoice, status: :paid)&#10;        invoice.destroy&#10;        expect(invoice.persisted?).to be true&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'client session handling during destruction' do&#10;    context 'when invoice is destroyed' do&#10;      it 'removes invoice association from client sessions' do&#10;        client = create(:client)&#10;        invoice = create(:invoice, client: client, status: :created)&#10;        client_session = create(:client_session, client: client, invoice: invoice)&#10;&#10;        invoice.destroy&#10;        client_session.reload&#10;        expect(client_session.invoice_id).to be_nil&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'date initialization' do&#10;    let(:client) { create(:client) }&#10;&#10;    it 'sets date to current date when creating a new invoice without specifying date' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        invoice = Invoice.new(client: client)&#10;        expect(invoice.date).to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'does not override explicitly set date when creating new invoice' do&#10;      custom_date = Date.new(2025, 6, 15)&#10;      invoice = Invoice.new(client: client, date: custom_date)&#10;      expect(invoice.date).to eq(custom_date)&#10;    end&#10;&#10;    it 'does not set date when loading existing invoice from database' do&#10;      # Create an invoice with a specific date&#10;      invoice = create(:invoice, client: client, date: Date.new(2025, 1, 1))&#10;&#10;      # Reload from database and verify date hasn't changed&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        reloaded_invoice = Invoice.find(invoice.id)&#10;        expect(reloaded_invoice.date).to eq(Date.new(2025, 1, 1))&#10;        expect(reloaded_invoice.date).not_to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'sets date when building through association' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        invoice = client.invoices.build&#10;        expect(invoice.date).to eq(Date.current)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'message text population' do&#10;    let(:client) { create(:client) }&#10;&#10;    it 'populates text from messages sorted by created_at date' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        # Create two messages with different creation times&#10;        older_message = create(:message, text: &quot;This is the first message&quot;)&#10;        newer_message = create(:message, text: &quot;This is the second message&quot;)&#10;&#10;        # Manually set different created_at times to ensure ordering&#10;        older_message.update_column(:created_at, 2.hours.ago)&#10;        newer_message.update_column(:created_at, 1.hour.ago)&#10;&#10;        # Associate both messages with the client&#10;        older_message.apply_to_client(client)&#10;        newer_message.apply_to_client(client)&#10;&#10;        # Create new invoice which should populate text from messages&#10;        invoice = Invoice.new(client: client)&#10;&#10;        # Expected text should have messages in chronological order (oldest first)&#10;        expected_text = &quot;This is the first message\n\nThis is the second message&quot;&#10;        expect(invoice.text.to_plain_text.strip).to eq(expected_text)&#10;      end&#10;    end&#10;  end&#10;end" />
              <option name="updatedContent" value="require 'rails_helper'&#10;&#10;RSpec.describe Invoice do&#10;  include ActiveSupport::Testing::TimeHelpers&#10;&#10;  describe 'FactoryBot' do&#10;    subject(:invoice) { create(:invoice) }&#10;&#10;    specify { expect(invoice.date).to eq Date.new(2025, 2, 1) }&#10;    specify { expect(invoice.client_sessions.length).to eq 3 }&#10;  end&#10;&#10;  describe '::create' do&#10;    context 'when it is a new invoice' do&#10;      let(:invoice_params) { attributes_for(:invoice, client_id: client.id) }&#10;      let(:client) { create(:client, :with_client_sessions) }&#10;&#10;      it 'creates the invoice and associates all the client sessions' do&#10;        client_session_ids = client.client_session_ids&#10;        amount = Money.new(ClientSession.where(id: client_session_ids).sum(&amp;:fee), 'GBP')&#10;&#10;        invoice_params[:client_session_ids] = client_session_ids&#10;&#10;        invoice = Invoice.create(invoice_params)&#10;&#10;        expect(invoice.client_sessions.pluck(:id)).to match client_session_ids&#10;        expect(invoice.amount).to eq(amount)&#10;      end&#10;&#10;      it 'creates the invoice and associates some of the client sessions' do&#10;        client_session_ids = client.client_session_ids&#10;        first_client_session_id = client_session_ids.pop&#10;&#10;        invoice_params[:client_session_ids] = client_session_ids&#10;        invoice = Invoice.create(invoice_params)&#10;&#10;        expect(invoice.client_sessions.pluck(:id)).to match client_session_ids&#10;        expect(ClientSession.find(first_client_session_id).invoice_id).to be_nil&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'destruction' do&#10;    context 'when invoice status is created' do&#10;      it 'allows destruction' do&#10;        invoice = create(:invoice, status: :created)&#10;        expect(invoice.destroy).not_to be_falsey&#10;        expect(invoice.persisted?).to be_falsey&#10;      end&#10;    end&#10;&#10;    context 'when invoice status is sent' do&#10;      it 'prevents destruction' do&#10;        invoice = create(:invoice, status: :sent)&#10;        expect(invoice.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        invoice = create(:invoice, status: :sent)&#10;        invoice.destroy&#10;        expect(invoice.persisted?).to be true&#10;      end&#10;    end&#10;&#10;    context 'when invoice status is paid' do&#10;      it 'prevents destruction' do&#10;        invoice = create(:invoice, status: :paid)&#10;        expect(invoice.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        invoice = create(:invoice, status: :paid)&#10;        invoice.destroy&#10;        expect(invoice.persisted?).to be true&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'client session handling during destruction' do&#10;    context 'when invoice is destroyed' do&#10;      it 'removes invoice association from client sessions' do&#10;        client = create(:client)&#10;        invoice = create(:invoice, client: client, status: :created)&#10;        client_session = create(:client_session, client: client, invoice: invoice)&#10;&#10;        invoice.destroy&#10;        client_session.reload&#10;        expect(client_session.invoice_id).to be_nil&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'date initialization' do&#10;    let(:client) { create(:client) }&#10;&#10;    it 'sets date to current date when creating a new invoice without specifying date' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        invoice = Invoice.new(client: client)&#10;        expect(invoice.date).to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'does not override explicitly set date when creating new invoice' do&#10;      custom_date = Date.new(2025, 6, 15)&#10;      invoice = Invoice.new(client: client, date: custom_date)&#10;      expect(invoice.date).to eq(custom_date)&#10;    end&#10;&#10;    it 'does not set date when loading existing invoice from database' do&#10;      # Create an invoice with a specific date&#10;      invoice = create(:invoice, client: client, date: Date.new(2025, 1, 1))&#10;&#10;      # Reload from database and verify date hasn't changed&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        reloaded_invoice = Invoice.find(invoice.id)&#10;        expect(reloaded_invoice.date).to eq(Date.new(2025, 1, 1))&#10;        expect(reloaded_invoice.date).not_to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'sets date when building through association' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        invoice = client.invoices.build&#10;        expect(invoice.date).to eq(Date.current)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'message text population' do&#10;    let(:client) { create(:client) }&#10;&#10;    it 'populates text from messages sorted by created_at date' do&#10;      travel_to Time.zone.local(2025, 7, 12, 10, 0, 0) do&#10;        # Create two messages with different creation times&#10;        older_message = create(:message, text: &quot;This is the first message&quot;)&#10;        newer_message = create(:message, text: &quot;This is the second message&quot;)&#10;&#10;        # Manually set different created_at times to ensure ordering&#10;        older_message.update_column(:created_at, 2.hours.ago)&#10;        newer_message.update_column(:created_at, 1.hour.ago)&#10;&#10;        # Associate both messages with the client&#10;        older_message.apply_to_client(client)&#10;        newer_message.apply_to_client(client)&#10;&#10;        # Create new invoice which should populate text from messages&#10;        invoice = Invoice.new(client: client)&#10;&#10;        # Expected text should have messages in chronological order (oldest first)&#10;        expected_text = &quot;This is the first message\n\nThis is the second message&quot;&#10;        expect(invoice.text.to_plain_text.strip).to eq(expected_text)&#10;      end&#10;    end&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>