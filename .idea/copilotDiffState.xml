<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/models/credit_note.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/credit_note.rb" />
              <option name="originalContent" value="# Represents a credit note issued against an invoice&#10;class CreditNote &lt; ApplicationRecord&#10;  belongs_to :invoice, class_name: 'Invoice'&#10;  has_one_attached :pdf&#10;  has_rich_text :text&#10;&#10;  # Delegate client and payee to invoice&#10;  delegate :client, :payee, to: :invoice, allow_nil: true&#10;&#10;  monetize :amount_pence&#10;&#10;  validates :date, presence: true&#10;  validates :invoice_id, presence: true&#10;  validates :reason, presence: true&#10;  validates :amount_pence, presence: true, numericality: { other_than: 0, message: &quot;cannot be zero&quot; }&#10;  validate :amount_cannot_exceed_invoice_amount&#10;  validate :invoice_must_be_sent_or_paid&#10;  validate :validate_editable_status, on: :update&#10;&#10;  enum :status, { created: 0, sent: 1 }&#10;&#10;  before_validation :ensure_negative_amount&#10;  after_initialize :set_default_date, if: :new_record?&#10;  before_destroy :deletable?&#10;&#10;&#10;  def summary&#10;    &quot;Credit Note ##{self.id} for Invoice ##{self.invoice_id}&quot;&#10;  end&#10;&#10;  # Returns the entity (Client or Payee) who should receive the credit note&#10;  def bill_to&#10;    payee || client&#10;  end&#10;&#10;  # Returns true if this credit note is billed to the client directly&#10;  def self_paid?&#10;    payee.nil?&#10;  end&#10;&#10;  private&#10;&#10;  def amount_cannot_exceed_invoice_amount&#10;    return if invoice.nil? || amount.nil?&#10;&#10;    if amount.abs &gt; invoice.amount.abs&#10;      errors.add(:amount, &quot;cannot exceed invoice amount of #{invoice.amount.format}&quot;)&#10;    end&#10;  end&#10;&#10;  def invoice_must_be_sent_or_paid&#10;    unless invoice.sent? || invoice.paid?&#10;      errors.add(:invoice, &quot;must be sent or paid before issuing a credit note&quot;)&#10;    end&#10;  end&#10;&#10;  def validate_editable_status&#10;    non_status_changes = changed_attributes.keys - %w[status updated_at]&#10;    non_status_changes.push(:text) if self.text.body_changed?&#10;&#10;    # Check if any non-status fields are being changed when status is not 'created'&#10;    non_status_changes_ok?(non_status_changes)&#10;&#10;    # Check status transition rules&#10;    status_change_ok?&#10;  end&#10;&#10;  def status_change_ok?&#10;    if status_changed?&#10;      case status_was&#10;      when &quot;created&quot;&#10;        # From 'created', can only go to 'sent'&#10;        unless status == &quot;sent&quot;&#10;          errors.add(:status, &quot;invalid status transition&quot;)&#10;        end&#10;      when &quot;sent&quot;&#10;        # From 'sent', cannot change to any other status&#10;        errors.add(:status, &quot;cannot change status once sent&quot;)&#10;      end&#10;    end&#10;  end&#10;&#10;  def non_status_changes_ok?(non_status_changes)&#10;    return if status_was == &quot;created&quot;&#10;&#10;    non_status_changes.each do |attr|&#10;      errors.add(attr, &quot;cannot be changed once the credit note has been sent&quot;)&#10;    end&#10;  end&#10;&#10;&#10;  # Ensure amount is negative for credit notes&#10;  def ensure_negative_amount&#10;    if amount.present? &amp;&amp; amount_pence.present? &amp;&amp; amount_pence.positive?&#10;      self.amount_pence = -amount_pence.abs&#10;    end&#10;  end&#10;&#10;  # Sets the default date for new credit note records&#10;  def set_default_date&#10;    self.date ||= Date.current&#10;  end&#10;&#10;  # Returns true if this credit note can be deleted&#10;  def deletable?&#10;    throw :abort unless created?&#10;  end&#10;end&#10;&#10;" />
              <option name="updatedContent" value="# Represents a credit note issued against an invoice&#10;class CreditNote &lt; ApplicationRecord&#10;  belongs_to :invoice, class_name: 'Invoice'&#10;  has_one_attached :pdf&#10;  has_rich_text :text&#10;&#10;  # Delegate client and payee to invoice&#10;  delegate :client, :payee, to: :invoice, allow_nil: true&#10;&#10;  monetize :amount_pence&#10;&#10;  validates :date, presence: true&#10;  validates :invoice_id, presence: true&#10;  validates :reason, presence: true&#10;  validates :amount_pence, presence: true, numericality: { other_than: 0, message: &quot;cannot be zero&quot; }&#10;  validate :amount_cannot_exceed_invoice_amount&#10;  validate :invoice_must_be_sent_or_paid&#10;  validate :validate_editable_status, on: :update&#10;&#10;  enum :status, { created: 0, sent: 1 }&#10;&#10;  before_validation :ensure_negative_amount&#10;  after_initialize :set_default_date, if: :new_record?&#10;  before_destroy :deletable?&#10;&#10;&#10;  def summary&#10;    &quot;Credit Note ##{self.id} for Invoice ##{self.invoice_id}&quot;&#10;  end&#10;&#10;  # Returns the entity (Client or Payee) who should receive the credit note&#10;  def bill_to&#10;    payee || client&#10;  end&#10;&#10;  # Returns true if this credit note is billed to the client directly&#10;  def self_paid?&#10;    payee.nil?&#10;  end&#10;&#10;  private&#10;&#10;  def amount_cannot_exceed_invoice_amount&#10;    return if invoice.nil? || amount.nil?&#10;&#10;    if amount.abs &gt; invoice.amount.abs&#10;      errors.add(:amount, &quot;cannot exceed invoice amount of #{invoice.amount.format}&quot;)&#10;    end&#10;  end&#10;&#10;  def invoice_must_be_sent_or_paid&#10;    unless invoice.sent? || invoice.paid?&#10;      errors.add(:invoice, &quot;must be sent or paid before issuing a credit note&quot;)&#10;    end&#10;  end&#10;&#10;  def validate_editable_status&#10;    non_status_changes = changed_attributes.keys - %w[status updated_at]&#10;    non_status_changes.push(:text) if self.text.body_changed?&#10;&#10;    # Check if any non-status fields are being changed when status is not 'created'&#10;    non_status_changes_ok?(non_status_changes)&#10;&#10;    # Check status transition rules&#10;    status_change_ok?&#10;  end&#10;&#10;  def status_change_ok?&#10;    if status_changed?&#10;      case status_was&#10;      when &quot;created&quot;&#10;        # From 'created', can only go to 'sent'&#10;        unless status == &quot;sent&quot;&#10;          errors.add(:status, &quot;invalid status transition&quot;)&#10;        end&#10;      when &quot;sent&quot;&#10;        # From 'sent', cannot change to any other status&#10;        errors.add(:status, &quot;cannot change status once sent&quot;)&#10;      end&#10;    end&#10;  end&#10;&#10;  def non_status_changes_ok?(non_status_changes)&#10;    return if status_was == &quot;created&quot;&#10;&#10;    non_status_changes.each do |attr|&#10;      errors.add(attr, &quot;cannot be changed once the credit note has been sent&quot;)&#10;    end&#10;  end&#10;&#10;&#10;  # Ensure amount is negative for credit notes&#10;  def ensure_negative_amount&#10;    if amount.present? &amp;&amp; amount_pence.present? &amp;&amp; amount_pence.positive?&#10;      self.amount_pence = -amount_pence.abs&#10;    end&#10;  end&#10;&#10;  # Sets the default date for new credit note records&#10;  def set_default_date&#10;    self.date ||= Date.current&#10;  end&#10;&#10;  # Returns true if this credit note can be deleted&#10;  def deletable?&#10;    throw :abort unless created?&#10;  end&#10;end&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/spec/factories/credit_notes.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/spec/factories/credit_notes.rb" />
              <option name="originalContent" value="FactoryBot.define do&#10;  factory :credit_note do&#10;    transient do&#10;      invoice_param { nil }&#10;    end&#10;    &#10;    # Invoice is required - let tests provide it&#10;    invoice { invoice_param }&#10;&#10;    amount { Money.new(-2500, &quot;GBP&quot;) } # -£25.00&#10;    reason { &quot;Test credit note reason&quot; }&#10;    date   { Date.current }&#10;    status { :created }&#10;  end&#10;end&#10;&#10;" />
              <option name="updatedContent" value="FactoryBot.define do&#10;  factory :credit_note do&#10;    transient do&#10;      invoice_param { nil }&#10;    end&#10;    &#10;    # Invoice is required - let tests provide it&#10;    invoice { invoice_param }&#10;&#10;    amount { Money.new(-2500, &quot;GBP&quot;) } # -£25.00&#10;    reason { &quot;Test credit note reason&quot; }&#10;    date   { Date.current }&#10;    status { :created }&#10;  end&#10;end&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>