<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/spec/models/credit_note_spec.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/spec/models/credit_note_spec.rb" />
              <option name="originalContent" value="require 'rails_helper'&#10;&#10;RSpec.describe CreditNote do&#10;  include ActiveSupport::Testing::TimeHelpers&#10;&#10;  describe 'FactoryBot' do&#10;    subject(:credit_note) { create(:credit_note) }&#10;&#10;    specify { expect(credit_note.invoice).to be_present }&#10;    specify { expect(credit_note.client).to be_present }&#10;    specify { expect(credit_note.amount).to be_negative }&#10;    specify { expect(credit_note.reason).to be_present }&#10;  end&#10;&#10;  describe '::create' do&#10;    context 'when it is a new credit note' do&#10;      let(:invoice) { create(:invoice, status: :sent, client: client) }&#10;      let(:client) { create(:client) }&#10;      let(:credit_note_params) do&#10;        {&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Customer requested refund',&#10;          date: Date.current&#10;        }&#10;      end&#10;&#10;      it 'creates the credit note with negative amount' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note).to be_persisted&#10;        expect(credit_note.amount).to be_negative&#10;        expect(credit_note.amount.abs).to eq(Money.new(5000, 'GBP'))&#10;      end&#10;&#10;      it 'creates the credit note associated with the invoice' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.invoice).to eq(invoice)&#10;        expect(invoice.credit_notes).to include(credit_note)&#10;      end&#10;&#10;      it 'creates the credit note with the same client as the invoice' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.client).to eq(client)&#10;        expect(credit_note.client).to eq(invoice.client)&#10;      end&#10;&#10;      it 'sets the payee from the invoice' do&#10;        payee = create(:payee)&#10;        invoice.update!(payee: payee)&#10;&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.payee).to eq(payee)&#10;        expect(credit_note.payee).to eq(invoice.payee)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'validations' do&#10;    let(:invoice) { create(:invoice, status: :sent, client: client) }&#10;    let(:client) { create(:client) }&#10;&#10;    describe 'invoice_id presence' do&#10;      it 'requires an invoice' do&#10;        credit_note = CreditNote.new(&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:invoice_id]).to include(&quot;can't be blank&quot;)&#10;      end&#10;    end&#10;&#10;    describe 'reason presence' do&#10;      it 'requires a reason' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP')&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:reason]).to include(&quot;can't be blank&quot;)&#10;      end&#10;    end&#10;&#10;    describe 'amount validation' do&#10;      it 'validates amount does not exceed invoice amount' do&#10;        invoice_amount = invoice.amount&#10;        excessive_amount = Money.new(invoice_amount.cents + 10000, 'GBP')&#10;&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: excessive_amount,&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot exceed invoice amount of #{invoice_amount.format}&quot;)&#10;      end&#10;&#10;      it 'allows amount equal to invoice amount' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: invoice.amount,&#10;          reason: 'Full refund'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;&#10;      it 'allows amount less than invoice amount' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(invoice.amount.cents / 2, 'GBP'),&#10;          reason: 'Partial refund'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;    end&#10;&#10;    describe 'invoice status validation' do&#10;      it 'prevents creating credit note for created invoice' do&#10;        created_invoice = create(:invoice, status: :created, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: created_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:invoice]).to include(&quot;must be sent or paid before issuing a credit note&quot;)&#10;      end&#10;&#10;      it 'allows creating credit note for sent invoice' do&#10;        sent_invoice = create(:invoice, status: :sent, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: sent_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;&#10;      it 'allows creating credit note for paid invoice' do&#10;        paid_invoice = create(:invoice, status: :paid, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: paid_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'destruction' do&#10;    let(:credit_note) { create(:credit_note) }&#10;&#10;    context 'when credit note status is created' do&#10;      it 'allows destruction' do&#10;        expect(credit_note.destroy).not_to be_falsey&#10;        expect(credit_note.persisted?).to be_falsey&#10;      end&#10;    end&#10;&#10;    context 'when credit note status is sent' do&#10;      before { credit_note.update!(status: :sent) }&#10;&#10;      it 'prevents destruction' do&#10;        expect(credit_note.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        credit_note.destroy&#10;        expect(credit_note.persisted?).to be true&#10;      end&#10;    end&#10;&#10;    context 'when credit note status is applied' do&#10;      before { credit_note.update!(status: :applied) }&#10;&#10;      it 'prevents destruction' do&#10;        expect(credit_note.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        credit_note.destroy&#10;        expect(credit_note.persisted?).to be true&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'date initialization' do&#10;    let(:invoice) { create(:invoice, status: :sent) }&#10;&#10;    it 'sets date to current date when creating a new credit note without specifying date' do&#10;      travel_to Time.zone.local(2025, 11, 16, 10, 0, 0) do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: invoice.client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;        expect(credit_note.date).to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'does not override explicitly set date when creating new credit note' do&#10;      custom_date = Date.new(2025, 10, 15)&#10;      credit_note = CreditNote.new(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason',&#10;        date: custom_date&#10;      )&#10;      expect(credit_note.date).to eq(custom_date)&#10;    end&#10;&#10;    it 'does not set date when loading existing credit note from database' do&#10;      credit_note = create(:credit_note, invoice: invoice, date: Date.new(2025, 1, 1))&#10;&#10;      travel_to Time.zone.local(2025, 11, 16, 10, 0, 0) do&#10;        reloaded_credit_note = CreditNote.find(credit_note.id)&#10;        expect(reloaded_credit_note.date).to eq(Date.new(2025, 1, 1))&#10;        expect(reloaded_credit_note.date).not_to eq(Date.current)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'amount handling' do&#10;    let(:invoice) { create(:invoice, status: :sent) }&#10;&#10;    it 'automatically converts positive amount to negative' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      expect(credit_note.amount).to be_negative&#10;      expect(credit_note.amount_pence).to be_negative&#10;      expect(credit_note.amount.abs.cents).to eq(5000)&#10;    end&#10;&#10;    it 'keeps negative amount as negative' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(-5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      expect(credit_note.amount).to be_negative&#10;      expect(credit_note.amount_pence).to eq(-5000)&#10;    end&#10;&#10;    it 'stores amount as negative in database' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      credit_note.reload&#10;      expect(credit_note.amount_pence).to be &lt; 0&#10;      expect(credit_note.amount).to be_negative&#10;    end&#10;  end&#10;&#10;  describe '#validate_editable_status' do&#10;    let(:credit_note) { create(:credit_note, status: :created) }&#10;&#10;    shared_examples 'non-editable credit note' do&#10;      it 'prevents changing non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:date]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing reason field' do&#10;        credit_note.reason = 'Updated reason'&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:reason]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing amount field' do&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing text field' do&#10;        credit_note.text = 'Updated text'&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:text]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing status back to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to be_present&#10;      end&#10;&#10;      it 'prevents changing multiple non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:date]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;        expect(credit_note.errors[:reason]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;    end&#10;&#10;    context 'when status is created' do&#10;      it 'allows changing non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(3000, 'GBP')&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;&#10;      it 'allows changing status from created to sent' do&#10;        credit_note.status = :sent&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('sent')&#10;      end&#10;&#10;      it 'allows changing status from created to applied' do&#10;        credit_note.status = :applied&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('applied')&#10;      end&#10;&#10;      it 'allows changing both status and other fields simultaneously' do&#10;        credit_note.status = :sent&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;    end&#10;&#10;    context 'when status is sent' do&#10;      before { credit_note.update!(status: :sent) }&#10;&#10;      it_behaves_like 'non-editable credit note'&#10;&#10;      it 'allows changing status from sent to applied' do&#10;        credit_note.status = :applied&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('applied')&#10;      end&#10;&#10;      it 'prevents changing status from sent to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to be_present&#10;      end&#10;    end&#10;&#10;    context 'when status is applied' do&#10;      before { credit_note.update!(status: :applied) }&#10;&#10;      it_behaves_like 'non-editable credit note'&#10;&#10;      it 'prevents changing status from applied to sent' do&#10;        credit_note.status = :sent&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing status from applied to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;      end&#10;    end&#10;&#10;    context 'edge cases' do&#10;      it 'allows status to remain the same while changing other fields when status is created' do&#10;        credit_note.status = :created&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;&#10;      it 'handles multiple validation errors correctly' do&#10;        credit_note.update!(status: :sent)&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors.count).to be &gt; 1&#10;        expect(credit_note.errors[:status]).to be_present&#10;        expect(credit_note.errors[:date]).to be_present&#10;        expect(credit_note.errors[:reason]).to be_present&#10;        expect(credit_note.errors[:amount]).to be_present&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'status transitions' do&#10;    let(:credit_note) { create(:credit_note) }&#10;&#10;    it 'allows transition from created to sent' do&#10;      credit_note.status = :sent&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'allows transition from created to applied' do&#10;      credit_note.status = :applied&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'allows transition from sent to applied' do&#10;      credit_note.update!(status: :sent)&#10;      credit_note.status = :applied&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'prevents transition from sent to created' do&#10;      credit_note.update!(status: :sent)&#10;      credit_note.status = :created&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to be_present&#10;    end&#10;&#10;    it 'prevents transition from applied to sent' do&#10;      credit_note.update!(status: :applied)&#10;      credit_note.status = :sent&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;    end&#10;&#10;    it 'prevents transition from applied to created' do&#10;      credit_note.update!(status: :applied)&#10;      credit_note.status = :created&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;    end&#10;  end&#10;&#10;  describe 'invoice association' do&#10;    let(:invoice) { create(:invoice, status: :sent) }&#10;    let(:credit_note) { create(:credit_note, invoice: invoice) }&#10;&#10;    it 'belongs to an invoice' do&#10;      expect(credit_note.invoice).to eq(invoice)&#10;    end&#10;&#10;    it 'is included in invoice credit_notes collection' do&#10;      expect(invoice.credit_notes).to include(credit_note)&#10;    end&#10;&#10;    it 'can have multiple credit notes for one invoice' do&#10;      credit_note2 = create(:credit_note, invoice: invoice, amount: Money.new(-2000, 'GBP'))&#10;&#10;      expect(invoice.credit_notes.count).to eq(2)&#10;      expect(invoice.credit_notes).to include(credit_note, credit_note2)&#10;    end&#10;  end&#10;&#10;  describe '#summary' do&#10;    let(:credit_note) { create(:credit_note) }&#10;&#10;    it 'returns a summary with credit note and invoice IDs' do&#10;      expected_summary = &quot;Credit Note ##{credit_note.id} for Invoice ##{credit_note.invoice_id}&quot;&#10;      expect(credit_note.summary).to eq(expected_summary)&#10;    end&#10;  end&#10;&#10;  describe 'inheritance from Billing' do&#10;    let(:credit_note) { create(:credit_note) }&#10;&#10;    it 'inherits from Billing class' do&#10;      expect(credit_note).to be_a(Billing)&#10;    end&#10;&#10;    it 'uses the billings table' do&#10;      expect(CreditNote.table_name).to eq('billings')&#10;    end&#10;&#10;    it 'has type set to CreditNote' do&#10;      expect(credit_note.type).to eq('CreditNote')&#10;    end&#10;&#10;    it 'inherits bill_to method from Billing' do&#10;      expect(credit_note).to respond_to(:bill_to)&#10;      expect(credit_note.bill_to).to eq(credit_note.client)&#10;    end&#10;&#10;    it 'inherits self_paid? method from Billing' do&#10;      expect(credit_note).to respond_to(:self_paid?)&#10;      expect(credit_note.self_paid?).to be true&#10;    end&#10;&#10;    context 'with payee' do&#10;      let(:payee) { create(:payee) }&#10;      let(:invoice) { create(:invoice, status: :sent, payee: payee) }&#10;      let(:credit_note) { create(:credit_note, invoice: invoice, payee: payee) }&#10;&#10;      it 'bill_to returns payee when present' do&#10;        expect(credit_note.bill_to).to eq(payee)&#10;      end&#10;&#10;      it 'self_paid? returns false when payee is present' do&#10;        expect(credit_note.self_paid?).to be false&#10;      end&#10;    end&#10;  end&#10;end&#10;&#10;" />
              <option name="updatedContent" value="require 'rails_helper'&#10;&#10;RSpec.describe CreditNote do&#10;  include ActiveSupport::Testing::TimeHelpers&#10;&#10;  # Helper to create a valid invoice with amount for testing credit notes&#10;  def create_sent_invoice(client: nil, amount_pence: 10000)&#10;    client ||= create(:client)&#10;    invoice = create(:invoice_with_client_sessions, client: client, client_sessions_count: 1)&#10;    invoice.update_column(:status, 1) # Mark as sent&#10;    invoice&#10;  end&#10;&#10;  describe 'FactoryBot' do&#10;    let(:invoice) { create_sent_invoice }&#10;    subject(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    specify { expect(credit_note.invoice).to be_present }&#10;    specify { expect(credit_note.client).to be_present }&#10;    specify { expect(credit_note.amount).to be_negative }&#10;    specify { expect(credit_note.reason).to be_present }&#10;  end&#10;&#10;  describe '::create' do&#10;    context 'when it is a new credit note' do&#10;      let(:invoice) { create(:invoice, status: :sent, client: client) }&#10;      let(:client) { create(:client) }&#10;      let(:credit_note_params) do&#10;        {&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Customer requested refund',&#10;          date: Date.current&#10;        }&#10;      end&#10;&#10;      it 'creates the credit note with negative amount' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note).to be_persisted&#10;        expect(credit_note.amount).to be_negative&#10;        expect(credit_note.amount.abs).to eq(Money.new(5000, 'GBP'))&#10;      end&#10;&#10;      it 'creates the credit note associated with the invoice' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.invoice).to eq(invoice)&#10;        expect(invoice.credit_notes).to include(credit_note)&#10;      end&#10;&#10;      it 'creates the credit note with the same client as the invoice' do&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.client).to eq(client)&#10;        expect(credit_note.client).to eq(invoice.client)&#10;      end&#10;&#10;      it 'sets the payee from the invoice' do&#10;        payee = create(:payee)&#10;        invoice.update!(payee: payee)&#10;&#10;        credit_note = CreditNote.create(credit_note_params)&#10;&#10;        expect(credit_note.payee).to eq(payee)&#10;        expect(credit_note.payee).to eq(invoice.payee)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'validations' do&#10;    let(:invoice) { create(:invoice, status: :sent, client: client) }&#10;    let(:client) { create(:client) }&#10;&#10;    describe 'invoice_id presence' do&#10;      it 'requires an invoice' do&#10;        credit_note = CreditNote.new(&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:invoice_id]).to include(&quot;can't be blank&quot;)&#10;      end&#10;    end&#10;&#10;    describe 'reason presence' do&#10;      it 'requires a reason' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP')&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:reason]).to include(&quot;can't be blank&quot;)&#10;      end&#10;    end&#10;&#10;    describe 'amount validation' do&#10;      it 'validates amount does not exceed invoice amount' do&#10;        invoice_amount = invoice.amount&#10;        excessive_amount = Money.new(invoice_amount.cents + 10000, 'GBP')&#10;&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: excessive_amount,&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot exceed invoice amount of #{invoice_amount.format}&quot;)&#10;      end&#10;&#10;      it 'allows amount equal to invoice amount' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: invoice.amount,&#10;          reason: 'Full refund'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;&#10;      it 'allows amount less than invoice amount' do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: client,&#10;          amount: Money.new(invoice.amount.cents / 2, 'GBP'),&#10;          reason: 'Partial refund'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;    end&#10;&#10;    describe 'invoice status validation' do&#10;      it 'prevents creating credit note for created invoice' do&#10;        created_invoice = create(:invoice, status: :created, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: created_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:invoice]).to include(&quot;must be sent or paid before issuing a credit note&quot;)&#10;      end&#10;&#10;      it 'allows creating credit note for sent invoice' do&#10;        sent_invoice = create(:invoice, status: :sent, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: sent_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;&#10;      it 'allows creating credit note for paid invoice' do&#10;        paid_invoice = create(:invoice, status: :paid, client: client)&#10;        credit_note = CreditNote.new(&#10;          invoice: paid_invoice,&#10;          client: client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;&#10;        expect(credit_note).to be_valid&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'destruction' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    context 'when credit note status is created' do&#10;      it 'allows destruction' do&#10;        expect(credit_note.destroy).not_to be_falsey&#10;        expect(credit_note.persisted?).to be_falsey&#10;      end&#10;    end&#10;&#10;    context 'when credit note status is sent' do&#10;      before { credit_note.update!(status: :sent) }&#10;&#10;      it 'prevents destruction' do&#10;        expect(credit_note.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        credit_note.destroy&#10;        expect(credit_note.persisted?).to be true&#10;      end&#10;    end&#10;&#10;    context 'when credit note status is applied' do&#10;      before { credit_note.update!(status: :applied) }&#10;&#10;      it 'prevents destruction' do&#10;        expect(credit_note.destroy).to be_falsey&#10;      end&#10;&#10;      it 'does not destroy the record' do&#10;        credit_note.destroy&#10;        expect(credit_note.persisted?).to be true&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'date initialization' do&#10;    let(:invoice) { create_sent_invoice }&#10;&#10;    it 'sets date to current date when creating a new credit note without specifying date' do&#10;      travel_to Time.zone.local(2025, 11, 16, 10, 0, 0) do&#10;        credit_note = CreditNote.new(&#10;          invoice: invoice,&#10;          client: invoice.client,&#10;          amount: Money.new(5000, 'GBP'),&#10;          reason: 'Test reason'&#10;        )&#10;        expect(credit_note.date).to eq(Date.current)&#10;      end&#10;    end&#10;&#10;    it 'does not override explicitly set date when creating new credit note' do&#10;      custom_date = Date.new(2025, 10, 15)&#10;      credit_note = CreditNote.new(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason',&#10;        date: custom_date&#10;      )&#10;      expect(credit_note.date).to eq(custom_date)&#10;    end&#10;&#10;    it 'does not set date when loading existing credit note from database' do&#10;      credit_note = create(:credit_note, invoice_param: invoice, date: Date.new(2025, 1, 1))&#10;&#10;      travel_to Time.zone.local(2025, 11, 16, 10, 0, 0) do&#10;        reloaded_credit_note = CreditNote.find(credit_note.id)&#10;        expect(reloaded_credit_note.date).to eq(Date.new(2025, 1, 1))&#10;        expect(reloaded_credit_note.date).not_to eq(Date.current)&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'amount handling' do&#10;    let(:invoice) { create_sent_invoice }&#10;&#10;    it 'automatically converts positive amount to negative' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      expect(credit_note.amount).to be_negative&#10;      expect(credit_note.amount_pence).to be_negative&#10;      expect(credit_note.amount.abs.cents).to eq(5000)&#10;    end&#10;&#10;    it 'keeps negative amount as negative' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(-5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      expect(credit_note.amount).to be_negative&#10;      expect(credit_note.amount_pence).to eq(-5000)&#10;    end&#10;&#10;    it 'stores amount as negative in database' do&#10;      credit_note = CreditNote.create(&#10;        invoice: invoice,&#10;        client: invoice.client,&#10;        amount: Money.new(5000, 'GBP'),&#10;        reason: 'Test reason'&#10;      )&#10;&#10;      credit_note.reload&#10;      expect(credit_note.amount_pence).to be &lt; 0&#10;      expect(credit_note.amount).to be_negative&#10;    end&#10;  end&#10;&#10;  describe '#validate_editable_status' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice, status: :created) }&#10;&#10;    shared_examples 'non-editable credit note' do&#10;      it 'prevents changing non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:date]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing reason field' do&#10;        credit_note.reason = 'Updated reason'&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:reason]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing amount field' do&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing text field' do&#10;        credit_note.text = 'Updated text'&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:text]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing status back to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to be_present&#10;      end&#10;&#10;      it 'prevents changing multiple non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:date]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;        expect(credit_note.errors[:reason]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;        expect(credit_note.errors[:amount]).to include(&quot;cannot be changed once the credit note has been sent or applied&quot;)&#10;      end&#10;    end&#10;&#10;    context 'when status is created' do&#10;      it 'allows changing non-status fields' do&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(3000, 'GBP')&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;&#10;      it 'allows changing status from created to sent' do&#10;        credit_note.status = :sent&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('sent')&#10;      end&#10;&#10;      it 'allows changing status from created to applied' do&#10;        credit_note.status = :applied&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('applied')&#10;      end&#10;&#10;      it 'allows changing both status and other fields simultaneously' do&#10;        credit_note.status = :sent&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;    end&#10;&#10;    context 'when status is sent' do&#10;      before { credit_note.update!(status: :sent) }&#10;&#10;      it_behaves_like 'non-editable credit note'&#10;&#10;      it 'allows changing status from sent to applied' do&#10;        credit_note.status = :applied&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;        expect(credit_note.reload.status).to eq('applied')&#10;      end&#10;&#10;      it 'prevents changing status from sent to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to be_present&#10;      end&#10;    end&#10;&#10;    context 'when status is applied' do&#10;      before { credit_note.update!(status: :applied) }&#10;&#10;      it_behaves_like 'non-editable credit note'&#10;&#10;      it 'prevents changing status from applied to sent' do&#10;        credit_note.status = :sent&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;      end&#10;&#10;      it 'prevents changing status from applied to created' do&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;      end&#10;    end&#10;&#10;    context 'edge cases' do&#10;      it 'allows status to remain the same while changing other fields when status is created' do&#10;        credit_note.status = :created&#10;        credit_note.date = Date.current + 1.day&#10;&#10;        expect(credit_note).to be_valid&#10;        expect(credit_note.save).to be true&#10;      end&#10;&#10;      it 'handles multiple validation errors correctly' do&#10;        credit_note.update!(status: :sent)&#10;        credit_note.date = Date.current + 1.day&#10;        credit_note.reason = 'Updated reason'&#10;        credit_note.amount = Money.new(-3000, 'GBP')&#10;        credit_note.status = :created&#10;&#10;        expect(credit_note).not_to be_valid&#10;        expect(credit_note.errors.count).to be &gt; 1&#10;        expect(credit_note.errors[:status]).to be_present&#10;        expect(credit_note.errors[:date]).to be_present&#10;        expect(credit_note.errors[:reason]).to be_present&#10;        expect(credit_note.errors[:amount]).to be_present&#10;      end&#10;    end&#10;  end&#10;&#10;  describe 'status transitions' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    it 'allows transition from created to sent' do&#10;      credit_note.status = :sent&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'allows transition from created to applied' do&#10;      credit_note.status = :applied&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'allows transition from sent to applied' do&#10;      credit_note.update!(status: :sent)&#10;      credit_note.status = :applied&#10;      expect(credit_note).to be_valid&#10;      expect(credit_note.save).to be true&#10;    end&#10;&#10;    it 'prevents transition from sent to created' do&#10;      credit_note.update!(status: :sent)&#10;      credit_note.status = :created&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to be_present&#10;    end&#10;&#10;    it 'prevents transition from applied to sent' do&#10;      credit_note.update!(status: :applied)&#10;      credit_note.status = :sent&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;    end&#10;&#10;    it 'prevents transition from applied to created' do&#10;      credit_note.update!(status: :applied)&#10;      credit_note.status = :created&#10;      expect(credit_note).not_to be_valid&#10;      expect(credit_note.errors[:status]).to include(&quot;cannot change status once applied&quot;)&#10;    end&#10;  end&#10;&#10;  describe 'invoice association' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    it 'belongs to an invoice' do&#10;      expect(credit_note.invoice).to eq(invoice)&#10;    end&#10;&#10;    it 'is included in invoice credit_notes collection' do&#10;      expect(invoice.credit_notes).to include(credit_note)&#10;    end&#10;&#10;    it 'can have multiple credit notes for one invoice' do&#10;      credit_note2 = create(:credit_note, invoice_param: invoice, amount: Money.new(-2000, 'GBP'))&#10;&#10;      expect(invoice.credit_notes.count).to eq(2)&#10;      expect(invoice.credit_notes).to include(credit_note, credit_note2)&#10;    end&#10;  end&#10;&#10;  describe '#summary' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    it 'returns a summary with credit note and invoice IDs' do&#10;      expected_summary = &quot;Credit Note ##{credit_note.id} for Invoice ##{credit_note.invoice_id}&quot;&#10;      expect(credit_note.summary).to eq(expected_summary)&#10;    end&#10;  end&#10;&#10;  describe 'inheritance from Billing' do&#10;    let(:invoice) { create_sent_invoice }&#10;    let(:credit_note) { create(:credit_note, invoice_param: invoice) }&#10;&#10;    it 'inherits from Billing class' do&#10;      expect(credit_note).to be_a(Billing)&#10;    end&#10;&#10;    it 'uses the billings table' do&#10;      expect(CreditNote.table_name).to eq('billings')&#10;    end&#10;&#10;    it 'has type set to CreditNote' do&#10;      expect(credit_note.type).to eq('CreditNote')&#10;    end&#10;&#10;    it 'inherits bill_to method from Billing' do&#10;      expect(credit_note).to respond_to(:bill_to)&#10;      expect(credit_note.bill_to).to eq(credit_note.client)&#10;    end&#10;&#10;    it 'inherits self_paid? method from Billing' do&#10;      expect(credit_note).to respond_to(:self_paid?)&#10;      expect(credit_note.self_paid?).to be true&#10;    end&#10;&#10;    context 'with payee' do&#10;      let(:payee) { create(:payee) }&#10;      let(:client) { create(:client) }&#10;      let(:invoice_with_payee) { create_sent_invoice(client: client) }&#10;      let(:credit_note) do &#10;        invoice_with_payee.update_column(:payee_id, payee.id)&#10;        create(:credit_note, invoice_param: invoice_with_payee, payee: payee)&#10;      end&#10;&#10;      it 'bill_to returns payee when present' do&#10;        expect(credit_note.bill_to).to eq(payee)&#10;      end&#10;&#10;      it 'self_paid? returns false when payee is present' do&#10;        expect(credit_note.self_paid?).to be false&#10;      end&#10;    end&#10;  end&#10;end&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>